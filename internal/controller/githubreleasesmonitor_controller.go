/*
Copyright 2024.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package controller

import (
	"context"
	"encoding/json"
	"fmt"
	"net/http"
	"time"

	"k8s.io/apimachinery/pkg/api/errors"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime"
	ctrl "sigs.k8s.io/controller-runtime"
	"sigs.k8s.io/controller-runtime/pkg/client"
	"sigs.k8s.io/controller-runtime/pkg/log"

	cvereleasev1 "github.com/cyse7125-su24-team10/cve-operator/api/v1"
	"github.com/go-logr/logr"
)

// GitHubReleasesMonitorReconciler reconciles a GitHubReleasesMonitor object
type GitHubReleasesMonitorReconciler struct {
	client.Client
	Scheme *runtime.Scheme
}

// +kubebuilder:rbac:groups=cve-release.skynetx.me,resources=githubreleasesmonitors,verbs=get;list;watch;create;update;patch;delete
// +kubebuilder:rbac:groups=cve-release.skynetx.me,resources=githubreleasesmonitors/status,verbs=get;update;patch
// +kubebuilder:rbac:groups=cve-release.skynetx.me,resources=githubreleasesmonitors/finalizers,verbs=update
//+kubebuilder:rbac:groups="",resources=namespaces,verbs=get;list;watch;create;update;patch;delete
// +kubebuilder:rbac:groups=batch,resources=jobs,verbs=get;list;watch;create;update;patch;delete
// +kubebuilder:rbac:groups=batch,resources=jobs/status,verbs=get

// Reconcile is part of the main kubernetes reconciliation loop which aims to
// move the current state of the cluster closer to the desired state.
// TODO(user): Modify the Reconcile function to compare the state specified by
// the GitHubReleasesMonitor object against the actual cluster state, and then
// perform operations to make the cluster state reflect the state specified by
// the user.
//
// For more details, check Reconcile and its Result here:
// - https://pkg.go.dev/sigs.k8s.io/controller-runtime@v0.18.4/pkg/reconcile
func (r *GitHubReleasesMonitorReconciler) Reconcile(ctx context.Context, req ctrl.Request) (ctrl.Result, error) {
	monitorLogger := log.FromContext(ctx)

	githubreleaseMonitor := &cvereleasev1.GitHubReleasesMonitor{}
	if err := r.Get(ctx, req.NamespacedName, githubreleaseMonitor); err != nil {
		monitorLogger.Error(err, "unable to fetch GitHubReleasesMonitor")
		return ctrl.Result{}, err
	}

	// Get all githubrelease jobs
	githubReleasesList := &cvereleasev1.GitHubReleaseList{}
	if err := r.List(ctx, githubReleasesList); err != nil {
		monitorLogger.Error(err, "unable to list GitHubReleases")
		return ctrl.Result{}, err
	}
	monitorFrom := githubreleaseMonitor.Spec.MonitorFrom
	if monitorFrom == "now" {
		//todo monitor from now logic
		//todo monitor from now logic
		// Get the current time in UTC and create url
		currentHour := time.Now().UTC().Truncate(time.Hour)
		dateStr := currentHour.Format("2006-01-02_1500Z")
		url := fmt.Sprintf(githubreleaseMonitor.Spec.URL+"/download/cve_%s/%s_delta_CVEs_at_%s.zip", dateStr, dateStr[:10], dateStr[11:16])
		monitorLogger.Info("URL: ", "url", url)
		if checkIfAllReleasesExist(githubReleasesList, githubreleaseMonitor) {
			// Create a GitHubRelease CR
			err := r.createRelease(ctx, req, url, monitorLogger, githubreleaseMonitor, dateStr[:10]+dateStr[11:15])
			if err != nil {
				monitorLogger.Error(err, "unable to create GitHubRelease")
				return ctrl.Result{}, err
			}
		}

		if checkForNewReleases(githubReleasesList, githubreleaseMonitor, url) {
			// Create a GitHubRelease CR
			err := r.createRelease(ctx, req, url, monitorLogger, githubreleaseMonitor, dateStr[:10]+dateStr[11:15])
			if err != nil {
				monitorLogger.Error(err, "unable to create GitHubRelease")
				return ctrl.Result{}, err
			}
		}

	} else {
		// Check if the githubreleases exists
		if checkIfAllReleasesExist(githubReleasesList, githubreleaseMonitor) {
			//
			monitorFrom := githubreleaseMonitor.Spec.MonitorFrom
			//todo monitor from last checked logic
			// Parse the input date
			inputDate, err := time.Parse("2006-01-02", monitorFrom)
			if err != nil {
				monitorLogger.Error(err, "Invalid date format. Please use YYYY-MM-DD.")
			}
			// dateStr := inputDate.Format("2006-01-02")
			// Get the current date
			currentDate := time.Now().UTC()

			// Calculate the number of days between the two dates
			daysBetween := int(currentDate.Sub(inputDate).Hours() / 24)
			for i := 0; i < daysBetween; i++ {
				currentDay := inputDate.AddDate(0, 0, i)
				dateStr := currentDay.Format("2006-01-02")
				url := fmt.Sprintf("https://github.com/CVEProject/cvelistV5/releases/download/cve_%s_at_end_of_day/%s_delta_CVEs_at_end_of_day.zip", dateStr, dateStr)
				monitorLogger.Info("URL: ", "url", url)
				// Create a GitHubRelease CR
				err := r.createRelease(ctx, req, url, monitorLogger, githubreleaseMonitor, dateStr)
				if err != nil {
					monitorLogger.Error(err, "unable to create GitHubRelease")
					return ctrl.Result{}, err
				}
			}
		}
	}

	if githubreleaseMonitor.Status.LastChecked.IsZero() {
		githubreleaseMonitor.Status.LastChecked = metav1.NewTime(time.Now())
	}
	githubreleaseMonitor.Status.LastChecked = metav1.NewTime(time.Now())
	githubreleaseMonitor.Status.MonitorFrom = metav1.NewTime(time.Now())
	if err := r.Status().Update(ctx, githubreleaseMonitor); err != nil {
		monitorLogger.Error(err, "unable to update GitHubReleasesMonitor status")
		return ctrl.Result{}, err
	}

	// Fetch the releases from https://github.com/CVEProject/cvelistV5/releases
	// if err := r.getReleases(url); err != nil {
	// 	monitorLogger.Error(err, "unable to fetch releases")
	// 	return ctrl.Result{}, err
	// }

	monitorLogger.Info("Reconciling GitHubReleasesMonitor")

	return ctrl.Result{RequeueAfter: 10 * time.Second}, nil
}

func checkForNewReleases(githubReleasesList *cvereleasev1.GitHubReleaseList, githubreleaseMonitor *cvereleasev1.GitHubReleasesMonitor, url string) bool {
	// check the spec url of releases with new releases
	for _, release := range githubReleasesList.Items {
		if release.Spec.URL != url {
			return true
		}
	}

	return false
}

func checkIfAllReleasesExist(githubReleasesList *cvereleasev1.GitHubReleaseList, githubreleaseMonitor *cvereleasev1.GitHubReleasesMonitor) bool {
	if len(githubReleasesList.Items) == 0 {
		return true
	} else if len(githubReleasesList.Items) != len(githubreleaseMonitor.Status.ReleasesFound) {
		return true
	} else {
		return false
	}
}

func (r *GitHubReleasesMonitorReconciler) createRelease(ctx context.Context, req ctrl.Request, url string, monitorLogger logr.Logger, githubreleaseMonitor *cvereleasev1.GitHubReleasesMonitor, dateStr string) error {
	// Create a GitHubRelease CR
	githubReleaseCR := &cvereleasev1.GitHubRelease{
		ObjectMeta: metav1.ObjectMeta{
			Name:      "github-release" + dateStr,
			Namespace: req.Namespace,
		},
		Spec: cvereleasev1.GitHubReleaseSpec{
			URL:           url,
			DockerSecret:  githubreleaseMonitor.Spec.DockerSecret,
			KafkaUser:     githubreleaseMonitor.Spec.KafkaUser,
			KafkaPassword: githubreleaseMonitor.Spec.KafkaPassword,
			KafkaBroker0:  githubreleaseMonitor.Spec.KafkaBroker0,
			KafkaBroker1:  githubreleaseMonitor.Spec.KafkaBroker1,
			KafkaBroker2:  githubreleaseMonitor.Spec.KafkaBroker2,
			Image:         githubreleaseMonitor.Spec.Image,
		},
	}
	if err := r.Get(ctx, req.NamespacedName, githubReleaseCR); err != nil {
		monitorLogger.Error(err, "unable to fetch GitHubRelease")
		if err := r.Create(ctx, githubReleaseCR); err != nil && !errors.IsAlreadyExists(err) {
			monitorLogger.Error(err, "unable to create GitHubRelease")
			return err
		}
		if !contains(githubreleaseMonitor.Status.ReleasesFound, dateStr) {
			githubreleaseMonitor.Status.ReleasesFound = append(githubreleaseMonitor.Status.ReleasesFound, dateStr)
		}
	}
	return nil
}

func contains(slice []string, item string) bool {
	if len(slice) == 0 {
		return false
	}
	for _, str := range slice {
		if str == item {
			return true
		}
	}
	return false
}

func (r *GitHubReleasesMonitorReconciler) getReleases(url string) Release {
	var latestRelease Release
	res, err := http.Get(url)
	if err != nil {
		fmt.Println("error downloading")
	}
	defer res.Body.Close()
	if err := json.NewDecoder(res.Body).Decode(&latestRelease); err != nil {
		fmt.Println("error decoding")
	}
	return latestRelease
}

type Release struct {
	Name   string
	URL    string
	Assets []Asset
}

type Asset struct {
	Name               string
	URL                string
	BrowserDownloadURL string `json:"browser_download_url"`
}

// SetupWithManager sets up the controller with the Manager.
func (r *GitHubReleasesMonitorReconciler) SetupWithManager(mgr ctrl.Manager) error {
	return ctrl.NewControllerManagedBy(mgr).
		For(&cvereleasev1.GitHubReleasesMonitor{}).
		Complete(r)
}
